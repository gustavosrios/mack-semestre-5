# -*- coding: utf-8 -*-
"""Projeto_Aplicado_IV_A4 final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uZWlzXXQ7CIIRfHqQCMzJqhdwRg-Aj2n

<img src="https://raw.githubusercontent.com/scalabrinig/cdProjetoAplicadoIV/d093146488f56dfcf0ef286bcee8efe0e71b9c76/figuras/mackenzie_logo.jpg" width="25%" align="right"/>

# **PROJETO APLICADO IV - Ciência de Dados EaD - 2025/01**


# **Entrega 3**

---

# **Alimentando Informações: Um Estudo De Dados Nutricionais**
"""

#@title **Identificação do Grupo e Opção do Projeto**

#@markdown Integrantes do Grupo, nome completo em ordem alfabética (*informe: \<nome\>, \<matrícula\>*)
Aluno1 = 'Silas de Souza Ferreira, 10414793' #@param {type:"string"}
Aluno2 = 'Israel Soares do Nascimento Viana, 10414894' #@param {type:"string"}
Aluno3 = 'Gustavo Silva Rios, 10415824' #@param {type:"string"}
GitHub = 'https://github.com/gustavosrios/mack-semestre-5' #@param {type:"string"}

"""# **Introdução**

A análise de dados em saúde pública é essencial para a formulação de políticas
e estratégias voltadas à promoção do bem-estar da população. No Brasil, o Sistema
de Vigilância Alimentar e Nutricional (Sisvan), gerenciado pelo Ministério da Saúde,
desempenha um papel central no monitoramento do estado nutricional e dos hábitos
alimentares da população atendida na Atenção Primária à Saúde (APS). Esse sistema
consolida informações individualizadas e anonimizadas, permitindo avaliar indicadores
nutricionais e subsidiar ações governamentais para a promoção da alimentação adequada e
a prevenção de doenças associadas à nutrição.
Nos últimos anos, o Brasil tem enfrentado o duplo desafio da desnutrição em bolsões
de vulnerabilidade social e do aumento do excesso de peso na população. Dados do (Sisvan)
indicam que, em 2022, cerca de 14,2% das crianças menores de 5 anos apresentavam excesso
de peso, ao mesmo tempo em que déficits nutricionais persistem em regiões de difícil acesso.
Diante desse cenário, este projeto tem como objetivo analisar os dados nacionais do Sisvan
entre 2018 e 2023, buscando identificar padrões e tendências no estado nutricional da
população atendida pelo SUS.
Os principais objetivos incluem calcular a prevalência de desnutrição e excesso
de peso por ano, idade, sexo e região; relacionar esses achados a variáveis demográficas e
socioeconômicas, como a vinculação ao programa Auxílio Brasil; desenvolver visualizações
e modelos preditivos para classificar o estado nutricional e identificar fatores de risco; e
gerar recomendações para aprimorar as ações nutricionais na APS. A análise integrará
dados complementares do e-SUS APS e do Auxílio Brasil para enriquecer as conclusões e
apoiar a formulação de políticas públicas baseadas em evidências, reforçando o papel do
(Sisvan) na tomada de decisão em saúde

# **Referencial Teórico**

A Vigilância Alimentar e Nutricional (VAN), integrada à Atenção Primária no SUS, é responsável pelo monitoramento contínuo do estado nutricional e dos padrões alimentares da população. Utiliza dados antropométricos padronizados, como peso, estatura e IMC, interpretados segundo referências da OMS para diagnóstico de desnutrição, sobrepeso e obesidade. O Sisvan, principal sistema da VAN, também coleta marcadores de consumo alimentar e tem ampliado sua cobertura, especialmente entre grupos vulneráveis, com apoio de programas sociais como o Bolsa Família.

Apesar dos avanços, o Sisvan ainda enfrenta desafios quanto à cobertura heterogênea e à qualidade dos dados, sobretudo em regiões remotas. Estudos como os de Mrejen, Cruz e Rosa (2023), Aprelini et al. (2021) e Silva et al. (2022) demonstram tanto o potencial quanto as limitações da base de dados para identificar desigualdades e traçar perfis nutricionais da população brasileira.

Paralelamente, cresce o uso de técnicas de inteligência artificial (IA) e ciência de dados na análise nutricional em saúde pública. Algoritmos de aprendizado de máquina, como Random Forest, XGBoost e redes neurais artificiais, têm sido utilizados com sucesso para prever o risco de sobrepeso, classificar estados nutricionais e segmentar perfis de maior vulnerabilidade. Modelos supervisionados e não supervisionados possibilitam diagnósticos mais precisos, identificação de padrões ocultos e estratificação de riscos.

Além disso, a aplicação de análises espaciais, séries temporais e modelos preditivos tem viabilizado o monitoramento dinâmico da desnutrição e obesidade em diferentes territórios. Iniciativas como o Sisvan Web e painéis interativos com dados públicos promovem maior transparência, auxiliam gestores na tomada de decisão e demonstram como a incorporação da IA pode transformar grandes bases administrativas em ferramentas estratégicas de planejamento. Essa convergência entre ciência de dados e saúde pública aponta para um modelo de vigilância mais inteligente, proativo e fundamentado em evidências.

# **Diagrama de Solução**

O pipeline desenvolvido para este projeto contempla uma abordagem sistemática e modular, iniciando-se pela aquisição e integração de dados provenientes do Sisvan Web, e-SUS APS e Programa Auxílio Brasil, permitindo análises cruzadas entre fatores antropométricos, sociodemográficos e socioeconômicos. Após a coleta, os dados brutos são submetidos a um rigoroso processo de pré-processamento, que inclui limpeza, padronização, tratamento de inconsistências e imputação de valores ausentes, com foco na qualidade e integridade dos registros.

Na sequência, realiza-se uma Análise Exploratória de Dados (AED), com o objetivo de extrair estatísticas descritivas, identificar padrões e disparidades entre grupos, bem como avaliar a cobertura e qualidade dos dados do Sisvan em diferentes localidades e períodos. A etapa de visualização de dados se apoia em bibliotecas de visualização em Python/R, para gerar painéis interativos, mapas temáticos, séries temporais e comparações categóricas, visando comunicar os achados de forma acessível e informativa.

Complementando a análise descritiva, será implementada uma etapa de modelagem preditiva com foco exploratório, utilizando algoritmos de classificação (como árvores de decisão e florestas aleatórias) ou modelos estatísticos (regressão logística), a fim de investigar fatores preditores associados aos desfechos nutricionais. A validação dos resultados envolve tanto a verificação estatística (com métricas como acurácia e AUC-ROC), quanto a comparação com dados oficiais e literatura prévia, além de testes de robustez com validação cruzada temporal.

Por fim, os resultados serão sintetizados em forma de insights acionáveis, embasando recomendações para formulação de políticas públicas e estratégias de intervenção em saúde nutricional. Todo o processo será documentado em relatórios técnico-científicos com enfoque em reprodutibilidade e transparência metodológica.

# **EDA**

Exploração e análise dos dados. Discussão e análise dos dados empregados (qualidade, limitações, simplicações ou recortes adotados etc.)
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
#import plotly.graph_objects as go
#import plotly.express as px
#import plotly.colors as pc
#import scipy.stats as stats
#import re
#import os

import warnings
warnings.filterwarnings('ignore')

pd.set_option('display.max_colwidth', None)  # Mostra todo o conteúdo das colunas de texto
pd.set_option('display.max_rows', None)  # Exibir todas as linhas
pd.set_option('display.max_columns', None)  # Exibir todas as colunas

"""### Dados Sisvan 2023"""

df_2023 = pd.read_csv('sisvan_estado_nutricional_2023.csv', encoding="ISO-8859-1", sep=';')

df_2023.shape

df_2023.columns

df_2023.shape

df_2023.isnull().sum()

df_2023 = df_2023.drop([
    'ST_PARTICIPA_ANDI', 'CO_ACOMPANHAMENTO', 'CO_MUNICIPIO_IBGE', 'CO_CNES',
    'NU_FASE_VIDA', 'CO_RACA_COR', 'CO_POVO_COMUNIDADE', 'CO_ESCOLARIDADE',
    'DS_IMC_PRE_GESTACIONAL', 'CO_ESTADO_NUTRI_IMC_SEMGEST',
    'CO_SISTEMA_ORIGEM_ACOMP','CO_PESSOA_SISVAN'], axis=1)

df_2023.shape

"""### Dados Sisvan 2022"""

df_2022 = pd.read_csv('sisvan_estado_nutricional_2022.csv', encoding="ISO-8859-1", sep=';')

df_2022 = df_2022.drop([
    'ST_PARTICIPA_ANDI', 'CO_ACOMPANHAMENTO', 'CO_MUNICIPIO_IBGE', 'CO_CNES',
    'NU_FASE_VIDA', 'CO_RACA_COR', 'CO_POVO_COMUNIDADE', 'CO_ESCOLARIDADE',
    'DS_IMC_PRE_GESTACIONAL', 'CO_ESTADO_NUTRI_IMC_SEMGEST',
    'CO_SISTEMA_ORIGEM_ACOMP','CO_PESSOA_SISVAN'], axis=1)

df_2022.shape

"""### Dados Sisvan 2021"""

df_2021 = pd.read_csv('sisvan_estado_nutricional_2021.csv', encoding="ISO-8859-1", sep=';', low_memory=False)

df_2021 = df_2021.drop([
    'ST_PARTICIPA_ANDI', 'CO_ACOMPANHAMENTO', 'CO_MUNICIPIO_IBGE', 'CO_CNES',
    'NU_FASE_VIDA', 'CO_RACA_COR', 'CO_POVO_COMUNIDADE', 'CO_ESCOLARIDADE',
    'DS_IMC_PRE_GESTACIONAL', 'CO_ESTADO_NUTRI_IMC_SEMGEST',
    'CO_SISTEMA_ORIGEM_ACOMP','CO_PESSOA_SISVAN'], axis=1)

df_2021.shape

"""### Dados Sisvan 2020"""

df_2020 = pd.read_csv('sisvan_estado_nutricional_2020.csv', encoding="ISO-8859-1", sep=';')

df_2020 = df_2020.drop([
    'ST_PARTICIPA_ANDI', 'CO_ACOMPANHAMENTO', 'CO_MUNICIPIO_IBGE', 'CO_CNES',
    'NU_FASE_VIDA', 'CO_RACA_COR', 'CO_POVO_COMUNIDADE', 'CO_ESCOLARIDADE',
    'DS_IMC_PRE_GESTACIONAL', 'CO_ESTADO_NUTRI_IMC_SEMGEST',
    'CO_SISTEMA_ORIGEM_ACOMP','CO_PESSOA_SISVAN'], axis=1)

df_2020.shape

"""### Dados Sisvan 2019"""

df_2019 = pd.read_csv('sisvan_estado_nutricional_2019.csv', encoding="ISO-8859-1", sep=';')

df_2019 = df_2019.drop([
    'ST_PARTICIPA_ANDI', 'CO_ACOMPANHAMENTO', 'CO_MUNICIPIO_IBGE', 'CO_CNES',
    'NU_FASE_VIDA', 'CO_RACA_COR', 'CO_POVO_COMUNIDADE', 'CO_ESCOLARIDADE',
    'DS_IMC_PRE_GESTACIONAL', 'CO_ESTADO_NUTRI_IMC_SEMGEST',
    'CO_SISTEMA_ORIGEM_ACOMP','CO_PESSOA_SISVAN'], axis=1)

df_2019.shape

"""### Dados Sisvan 2018"""

df_2018 = pd.read_csv('sisvan_estado_nutricional_2018.csv', encoding="ISO-8859-1", sep=';', low_memory=False)

df_2018 = df_2018.drop([
    'ST_PARTICIPA_ANDI', 'CO_ACOMPANHAMENTO', 'CO_MUNICIPIO_IBGE', 'CO_CNES',
    'NU_FASE_VIDA', 'CO_RACA_COR', 'CO_POVO_COMUNIDADE', 'CO_ESCOLARIDADE',
    'DS_IMC_PRE_GESTACIONAL', 'CO_ESTADO_NUTRI_IMC_SEMGEST',
    'CO_SISTEMA_ORIGEM_ACOMP','CO_PESSOA_SISVAN'], axis=1)

df_2018.shape

"""### Merge - Consolidação das Bases"""

lista_dfs = [df_2023, df_2022, df_2021, df_2020, df_2019, df_2018]
df_consolidado = pd.concat(lista_dfs, ignore_index=True)

df_consolidado.head()

df_consolidado.shape

df_consolidado.info()

df_consolidado.head(1)

df_consolidado.to_csv('sisvan_consolidado.csv', index=False, encoding="ISO-8859-1", sep=';')

"""### Leitura da Base Consolidada"""

df_consolidado = pd.read_csv('sisvan_consolidado.csv', encoding="ISO-8859-1", sep=';')

(df_consolidado['NU_IDADE_ANO'] < 10).sum()

"""### Verificação de dados nulos"""

import seaborn

plt.figure(figsize=(3,2))
sns.heatmap(df_consolidado.isnull(),
            yticklabels=False,
            cbar=False,
            cmap='viridis')
df_consolidado.isnull().sum() / len(df_consolidado)

"""### Verificação Dados Infinitos"""

plt.figure(figsize=(3,2))
sns.heatmap(np.isinf(df_consolidado.select_dtypes(include=['number'])),
            yticklabels=False,
            cbar=False,
            cmap='viridis')
np.isinf(df_consolidado.select_dtypes(include=['number'])).sum()

df_consolidado.info()

"""### Checando intervalo de datas (range)"""

print(f' Esta base vai de: {df_consolidado['DT_ACOMPANHAMENTO'].min()} até {df_consolidado['DT_ACOMPANHAMENTO'].max()}')

"""### Checando valores únicos e possíveis inconsistências em colunas categóricas"""

categorical_cols = ['SG_UF', 'NO_MUNICIPIO', 'DS_FASE_VIDA', 'SG_SEXO', 'DS_RACA_COR', 'DS_POVO_COMUNIDADE', 'DS_ESCOLARIDADE', 'SISTEMA_ORIGEM_ACOMP', 'CO_ESTADO_NUTRI_ADULTO', 'CO_ESTADO_NUTRI_IDOSO']

for col in categorical_cols:
    print(f"{col}: {df_consolidado[col].unique()}\n")

"""### Convertendo variável temporal para formato Datetime"""

df_consolidado['DT_ACOMPANHAMENTO'] = pd.to_datetime(df_consolidado['DT_ACOMPANHAMENTO'], dayfirst=True, errors='coerce')

"""### Checando Outliers ou valores inválidos em variáveis numéricas"""

df_consolidado[['NU_PESO', 'NU_ALTURA', 'DS_IMC']].describe()

df_consolidado.describe()

"""### Conversão de colunas numéricas
- `NU_PESO`, `NU_ALTURA`, `DS_IMC` estão como object, mas deveriam ser float;

- Há alta cardinalidade em `NU_PESO` e `DS_IMC` indicando valores possivelmente mal formatados (ex.: vírgula no lugar do ponto);

- Essas mudanças são necessárias para prosseguirmos com a análise exploratória pois muitas funções aceitam pontos e não virgulas.
"""

df_consolidado['NU_PESO'] = df_consolidado['NU_PESO'].str.replace(',', '.').astype(float)
df_consolidado['NU_ALTURA'] = df_consolidado['NU_ALTURA'].str.replace(',', '.').astype(float)
df_consolidado['DS_IMC'] = df_consolidado['DS_IMC'].str.replace(',', '.').astype(float)

"""### Remoção de Outliers
- Valores de Idade até 168 anos foram encontrados o que é estatisticamente improvável.
"""

# Quantidade de registros com idade maior que 120
outliers_idade = df_consolidado[df_consolidado['NU_IDADE_ANO'] > 120]
print(f"Quantidade de registros com idade > 120: {len(outliers_idade)}")

# Visualizar exemplos (opcional)
outliers_idade[['NO_MUNICIPIO', 'NU_IDADE_ANO', 'DS_FASE_VIDA', 'DT_ACOMPANHAMENTO']].head()

df_consolidado = df_consolidado[df_consolidado['NU_IDADE_ANO'] <= 120]

"""### Verificando valores extremos em Peso, Altura e IMC
- Com base nesse `describe()`, há valores extremos e inconsistentes que devem ser removidos antes da EDA, especialmente para evitar distorções em histogramas e boxplots;
- Peso 0 é impossível. Peso 999.9 é um erro de entrada evidente;
- Altura 0 ou 10 metros são impossíveis;
- IMC fisiologicamente plausível vai até ~60.
"""

df_consolidado[['NU_PESO', 'NU_ALTURA', 'DS_IMC']].describe()

"""### Verificação de inconsistências"""

# Verificações baseadas em impossibilidades absolutas (independente da idade)
peso_invalidos = df_consolidado[df_consolidado['NU_PESO'] <= 0]
altura_invalidos = df_consolidado[df_consolidado['NU_ALTURA'] <= 0]
peso_max_invalidos = df_consolidado[df_consolidado['NU_PESO'] > 200]  # excessivo mesmo para adultos
altura_max_invalidos = df_consolidado[df_consolidado['NU_ALTURA'] > 220]
imc_invalidos = df_consolidado[(df_consolidado['DS_IMC'] < 10) | (df_consolidado['DS_IMC'] > 60)]

print(f"Peso zero ou negativo: {len(peso_invalidos)}")
print(f"Altura zero ou negativa: {len(altura_invalidos)}")
print(f"Peso > 200kg: {len(peso_max_invalidos)}")
print(f"Altura > 220cm: {len(altura_max_invalidos)}")
print(f"IMC fora de faixa (10 a 60): {len(imc_invalidos)}")

"""### Estratégia de limpeza contextual por idade
- Vamos aplicar as regras apenas para valores impossíveis, sem excluir faixas válidas para recém-nascidos.
- Definindo faixas fisiológicas plausíveis com base em faixas etárias reais, para remover os extremos sem afetar dados legítimos de recém-nascidos ou crianças pequenas.

### Faixas Fisiológicas Ponderadas por Faixa Etária

| Faixa Etária         | Peso Mínimo (kg) | Peso Máximo (kg) | Altura Mínima (cm) | Altura Máxima (cm) |
|----------------------|------------------|------------------|---------------------|---------------------|
| Bebês (0 a 1 ano)    | 1.5              | 15               | 40                  | 90                  |
| Crianças (1 a 10 anos)| 9               | 40               | 75                  | 140                 |
| Adolescentes (10 a 19 anos)| 30         | 90               | 120                 | 190                 |
| Adultos (20 a 59 anos)| 40              | 200              | 140                 | 220                 |
| Idosos (60+ anos)    | 40              | 200*             | 140                 | 220*                |

\* Sem restrições específicas, apenas considerando limites fisiológicos máximos.
"""

df_consolidado = df_consolidado[
    (df_consolidado['NU_PESO'] >= 1.5) & (df_consolidado['NU_PESO'] <= 200) &
    (df_consolidado['NU_ALTURA'] >= 40) & (df_consolidado['NU_ALTURA'] <= 220) &
    (df_consolidado['DS_IMC'] >= 10) & (df_consolidado['DS_IMC'] <= 60)
]

"""# **Pré-processamento dos dados**

Exploração e análise dos dados. Discussão e análise dos dados empregados (qualidade, limitações, simplicações ou recortes adotados etc.). Tarefas de preparação dos dados (transformações, compactação e encodes, junções de dados etc.).

"""

def print_top_correlations(df):
    correlation_matrix = df.corr(numeric_only=True)
    plt.figure(figsize=(8,5))
    sns.heatmap(data=correlation_matrix,
                annot=True,
                cmap='RdYlGn')

    top_correlations = correlation_matrix.unstack().sort_values(ascending=False).drop_duplicates()

    # Pegue as 10 maiores correlações (ignorando a correlação com si mesmo, que sempre será 1.0)
    top_10_correlations = top_correlations[top_correlations.index.get_level_values(0) != top_correlations.index.get_level_values(1)].head(10)
    display(correlation_matrix)
    count = 0
    print(f'Maiores Correlações Positivas:')
    for index, value in top_10_correlations.items():
        count += 1
        print(f"{count}: {index[0]} - {index[1]}: {value}")

    # Pegue as 10 menores correlações (ignorando a correlação com si mesmo, que sempre será 1.0)
    top_10_correlations = top_correlations[top_correlations.index.get_level_values(0) != top_correlations.index.get_level_values(1)].tail(10)
    top_10_correlations.sort_values(ascending=True,inplace=True)
    count = 0
    print(f'\nMaiores Correlações Negativas:')
    for index, value in top_10_correlations.items():
        count += 1
        print(f"{count}: {index[0]} - {index[1]}: {value}")
print_top_correlations(df_consolidado)

"""### Distribuição da Idade
- Vamos começar com um histograma simples para visualizar a distribuição das idades:
"""

import plotly.express as px
import numpy as np
import pandas as pd

# Definir os bins manualmente
bins = list(np.arange(0, 115, 5))
labels = [f"{i}–{i+4}" for i in bins[:-1]]

# Criar coluna categórica ordenada
df_consolidado['IDADE_BIN'] = pd.cut(
    df_consolidado['NU_IDADE_ANO'],
    bins=bins,
    labels=labels,
    right=False,
    ordered=True
)

# Histograma com Plotly
fig = px.histogram(
    df_consolidado,
    x='IDADE_BIN',
    category_orders={'IDADE_BIN': labels},  # forçar ordenação correta
    title='Distribuição de Idade dos Indivíduos Acompanhados (2018–2023)',
    labels={'IDADE_BIN': 'Faixa Etária (anos)'},
    color_discrete_sequence=['lightblue']
)

fig.update_layout(
    xaxis_title='Faixa Etária (anos)',
    yaxis_title='Número de Registros',
    bargap=0.05
)

fig.show()

"""### Boxplot de IMC por Sexo"""

fig = px.box(
    df_consolidado,
    x='SG_SEXO',
    y='DS_IMC',
    color='SG_SEXO',
    title='Distribuição do IMC por Sexo',
    labels={'SG_SEXO': 'Sexo', 'DS_IMC': 'IMC'},
    color_discrete_sequence=px.colors.qualitative.Set2
)

fig.update_layout(
    yaxis_title='Índice de Massa Corporal (IMC)',
    xaxis_title='Sexo',
    showlegend=False
)

fig.show()

"""### Boxplot de IMC por Fase da Vida"""

ordem_fases = [
    'MENOR DE 6 MESES',
    'ENTRE 6 MESES A 2 ANOS',
    'ENTRE 2 ANOS A 5 ANOS',
    'ENTRE 5 ANOS A 7 ANOS',
    'ENTRE 7 ANOS A 10 ANOS',
    'ADOLESCENTE',
    'ADULTO',
    'IDOSO'
]

import plotly.express as px

fig = px.box(
    df_consolidado,
    x='DS_FASE_VIDA',
    y='DS_IMC',
    color='DS_FASE_VIDA',
    category_orders={'DS_FASE_VIDA': ordem_fases},
    title='Distribuição do IMC por Fase da Vida',
    labels={'DS_FASE_VIDA': 'Fase da Vida', 'DS_IMC': 'IMC'},
    color_discrete_sequence=px.colors.qualitative.Pastel
)

fig.update_layout(
    yaxis_title='Índice de Massa Corporal (IMC)',
    xaxis_title='Fase da Vida',
    xaxis_tickangle=45,
    showlegend=False
)

fig.show()

"""### Histograma de IMC (Geral)"""

# Definir os bins e rótulos para IMC
bins_imc = [0, 16, 17, 18.5, 25, 30, 35, 40, 60]
labels_imc = [
    '<16', '16–17', '17–18.4', '18.5–24.9',
    '25–29.9', '30–34.9', '35–39.9', '40+'
]

# Criar nova coluna categórica com os intervalos
df_consolidado['IMC_BIN'] = pd.cut(
    df_consolidado['DS_IMC'],
    bins=bins_imc,
    labels=labels_imc,
    right=False,
    ordered=True
)

# Criar histograma com Plotly
fig = px.histogram(
    df_consolidado,
    x='IMC_BIN',
    category_orders={'IMC_BIN': labels_imc},
    title='Distribuição do IMC na População',
    labels={'IMC_BIN': 'Faixa de IMC'},
    color_discrete_sequence=['lightblue']
)

fig.update_layout(
    xaxis_title='Faixa de IMC',
    yaxis_title='Número de Registros',
    bargap=0.05
)

fig.show()

import seaborn as sns
sns.histplot(df_consolidado['DS_IMC'], kde=True)

"""### Média de IMC por UF"""

df_imc_uf = df_consolidado.groupby('SG_UF')['DS_IMC'].mean().reset_index()

fig = px.bar(
    df_imc_uf,
    x='SG_UF',
    y='DS_IMC',
    title='Média de IMC por Estado (UF)',
    labels={'SG_UF': 'Estado (UF)', 'DS_IMC': 'IMC Médio'},
    color='DS_IMC',
    color_continuous_scale='Cividis'
)

fig.update_layout(
    xaxis_title='Estado (UF)',
    yaxis_title='IMC Médio'
)

fig.show()

"""### Análises Cruzadas (não temporais) - IMC médio por Perfil Demográfico
- Agrupados em Povos/Comunidades tradicionais;
- Agrupados por Escolaridade;
"""

import plotly.express as px

df_imc_comun = df_consolidado.groupby('DS_POVO_COMUNIDADE')['DS_IMC'].mean().reset_index().dropna()

fig = px.bar(
    df_imc_comun,
    x='DS_POVO_COMUNIDADE',
    y='DS_IMC',
    title='IMC Médio por Povo/Comunidade Tradicional',
    labels={'DS_POVO_COMUNIDADE': 'Povo/Comunidade', 'DS_IMC': 'IMC Médio'},
    color='DS_IMC',
    color_continuous_scale='viridis'
)

fig.update_layout(xaxis_tickangle=60)
fig.show()

df_imc_esc = df_consolidado.groupby('DS_ESCOLARIDADE')['DS_IMC'].mean().reset_index()

fig = px.bar(
    df_imc_esc,
    x='DS_ESCOLARIDADE',
    y='DS_IMC',
    title='IMC Médio por Escolaridade',
    labels={'DS_ESCOLARIDADE': 'Escolaridade', 'DS_IMC': 'IMC Médio'},
    color='DS_IMC',
    color_continuous_scale='viridis'
)

fig.update_layout(xaxis_tickangle=60)
fig.show()

"""### Análises de Risco Nutricional

Agora vamos focar em análises de risco nutricional, utilizando as variáveis de classificação do estado nutricional já presentes na base: `CO_ESTADO_NUTRI_ADULTO` e `CO_ESTADO_NUTRI_IDOSO`

Essas colunas indicam diretamente se a pessoa está com:

- Baixo peso

- Eutrofia (IMC adequado)

- Sobrepeso

- Obesidade grau I, II, III

### Frequência dos estados nutricionais em adultos

### Comparação entre Adultos e Idosos – Estado Nutricional
"""

# Filtrar apenas adultos e idosos
df_adultos = df_consolidado[df_consolidado['DS_FASE_VIDA'] == 'ADULTO']
df_idosos = df_consolidado[df_consolidado['DS_FASE_VIDA'] == 'IDOSO']

# Frequência proporcional por grupo
freq_adulto = df_adultos['CO_ESTADO_NUTRI_ADULTO'].value_counts(normalize=True).reset_index()
freq_adulto.columns = ['Estado Nutricional', 'Proporção']
freq_adulto['Grupo'] = 'Adulto'

freq_idoso = df_idosos['CO_ESTADO_NUTRI_IDOSO'].value_counts(normalize=True).reset_index()
freq_idoso.columns = ['Estado Nutricional', 'Proporção']
freq_idoso['Grupo'] = 'Idoso'

# Unir os dois
df_comparativo = pd.concat([freq_adulto, freq_idoso], ignore_index=True)
df_comparativo['Proporção'] *= 100  # em porcentagem

import plotly.express as px

fig = px.bar(
    df_comparativo,
    x='Estado Nutricional',
    y='Proporção',
    color='Grupo',
    barmode='group',
    text='Proporção',
    title='Comparação do Estado Nutricional entre Adultos e Idosos',
    labels={'Proporção': 'Proporção (%)'}
)

fig.update_traces(texttemplate='%{text:.1f}%', textposition='outside')
fig.update_layout(
    xaxis_tickangle=0,
    yaxis_range=[0, df_comparativo['Proporção'].max() + 5]
)

fig.show()

"""## Séries Temporais

### Construir séries temporais do estado nutricional ano a ano por grupo etário (adulto x idoso)
- Avaliar se o sobrepeso e a obesidade estão crescendo
- Entender se o baixo peso em idosos está se agravando
- Identificar impactos de políticas públicas ou eventos (como pandemia, programas de nutrição, etc.)
"""

import pandas as pd
import plotly.express as px

# Garantir coluna de ano a partir da data
df_consolidado['ANO'] = pd.to_datetime(df_consolidado['DT_ACOMPANHAMENTO'], dayfirst=True).dt.year

# ADULTOS
# -----------------------
# Filtrar adultos com estado nutricional válido
df_adultos = df_consolidado[
    (df_consolidado['DS_FASE_VIDA'] == 'ADULTO') &
    (df_consolidado['CO_ESTADO_NUTRI_ADULTO'].notna())
]

# Calcular proporção ano a ano
contagem_adulto = df_adultos.groupby(['ANO', 'CO_ESTADO_NUTRI_ADULTO']).size().reset_index(name='contagem')
soma_por_ano_adulto = contagem_adulto.groupby('ANO')['contagem'].transform('sum')
contagem_adulto['Proporção'] = 100 * contagem_adulto['contagem'] / soma_por_ano_adulto
contagem_adulto['Grupo'] = 'Adulto'
contagem_adulto = contagem_adulto.drop(columns='contagem')
contagem_adulto.columns = ['ANO', 'Estado Nutricional', 'Proporção', 'Grupo']

# IDOSOS
# -----------------------
# Filtrar idosos com estado nutricional válido
df_idosos = df_consolidado[
    (df_consolidado['DS_FASE_VIDA'] == 'IDOSO') &
    (df_consolidado['CO_ESTADO_NUTRI_IDOSO'].notna())
]

# Calcular proporção ano a ano
contagem_idoso = df_idosos.groupby(['ANO', 'CO_ESTADO_NUTRI_IDOSO']).size().reset_index(name='contagem')
soma_por_ano_idoso = contagem_idoso.groupby('ANO')['contagem'].transform('sum')
contagem_idoso['Proporção'] = 100 * contagem_idoso['contagem'] / soma_por_ano_idoso
contagem_idoso['Grupo'] = 'Idoso'
contagem_idoso = contagem_idoso.drop(columns='contagem')
contagem_idoso.columns = ['ANO', 'Estado Nutricional', 'Proporção', 'Grupo']

# UNIR E PLOTAR
# -----------------------
# Concatenar os dois
df_series_temporais = pd.concat([contagem_adulto, contagem_idoso], ignore_index=True)

# Gráfico
fig = px.line(
    df_series_temporais,
    x='ANO',
    y='Proporção',
    color='Estado Nutricional',
    line_dash='Grupo',
    markers=True,
    title='Evolução Anual do Estado Nutricional em Adultos e Idosos (2018–2023)',
    labels={'ANO': 'Ano', 'Proporção': 'Proporção (%)'},
)

fig.update_layout(
    xaxis=dict(dtick=1),
    yaxis_range=[0, df_series_temporais['Proporção'].max() + 5]
)

fig.show()

df_consolidado.head(1)

df_atendimentos_ano = df_consolidado.groupby('ANO').size().reset_index(name='Atendimentos')
display(df_atendimentos_ano)
fig = px.line(
    df_atendimentos_ano,
    x='ANO',
    y='Atendimentos',
    markers=True,
    title='Número de Acompanhamentos por Ano (2018–2023)',
    labels={'ANO': 'Ano', 'Atendimentos': 'Número de Registros'}
)
fig.update_layout(xaxis=dict(dtick=1))
fig.show()

"""### Média de IMC por ano
- Avaliar se o IMC médio a população está subindo ao longo do tempo.
"""

df_imc_ano = df_consolidado.groupby('ANO')['DS_IMC'].mean().reset_index()
display(df_imc_ano)
fig = px.line(
    df_imc_ano,
    x='ANO',
    y='DS_IMC',
    markers=True,
    title='Evolução da Média de IMC por Ano',
    labels={'ANO': 'Ano', 'DS_IMC': 'IMC Médio'}
)
fig.update_layout(xaxis=dict(dtick=1))
fig.show()

"""### IMC médio por ano separado por sexo
- Observar diferenças e tendências no IMC médio de homens e mulheres ao longo do tempo.
"""

df_imc_sexo = df_consolidado.groupby(['ANO', 'SG_SEXO'])['DS_IMC'].mean().reset_index()

fig = px.line(
    df_imc_sexo,
    x='ANO',
    y='DS_IMC',
    color='SG_SEXO',
    markers=True,
    title='Evolução da Média de IMC por Sexo (2018–2023)',
    labels={'ANO': 'Ano', 'DS_IMC': 'IMC Médio', 'SG_SEXO': 'Sexo'}
)
fig.update_layout(xaxis=dict(dtick=1))
fig.show()

"""### Média de IMC por ano e UF
- Monitorar variações regionais ao longo dos anos.
"""

df_imc_ano_uf = df_consolidado.groupby(['ANO', 'SG_UF'])['DS_IMC'].mean().reset_index()

fig = px.line(
    df_imc_ano_uf,
    x='ANO',
    y='DS_IMC',
    color='SG_UF',
    title='Média de IMC por UF ao Longo dos Anos',
    labels={'ANO': 'Ano', 'DS_IMC': 'IMC Médio', 'SG_UF': 'Estado (UF)'}
)
fig.update_layout(xaxis=dict(dtick=1))
fig.show()

"""# **Modelo Base** - Primeira Execução

Aplicação de, pelo menos, um primeiro modelo (modelo de aprendizado de máquina ou modelo estatístico) que deve ser refinado até a entrega final do projeto. Apresente o método aplicado e a análise dos resultados obtidos.

### Model Arima e Médias Móveis
ARIMA (AutoRegressive Integrated Moving Average) - Modelo estatístico clássico para séries temporais.

- Auto-Regressão (AR) → usa os próprios valores anteriores
- Integração (I) → diferenças sucessivas para estabilizar tendência
- Média Móvel (MA) → usa erros anteriores como correção
- Ideal para séries:
- Com tendência (subindo ou descendo)
- Sem forte padrão sazonal (ex: flutuação anual)

### Previsão de OBESIDADE - ADULTOS
"""

# Filtrar apenas adultos
df_adultos = df_consolidado[df_consolidado['DS_FASE_VIDA'] == 'ADULTO']

# Filtrar apenas quem tem estado nutricional disponível
df_adultos = df_adultos[df_adultos['CO_ESTADO_NUTRI_ADULTO'].notna()]

# Definir o que é considerado "obeso" para adultos
condicoes_obesidade = ['Sobrepeso', 'Obesidade Grau I', 'Obesidade Grau II', 'Obesidade Grau III']

# Série: percentual de obesos por ano
serie_obesidade_adultos = (
    df_adultos
    .groupby('ANO', group_keys=False)
    .apply(lambda x: (x['CO_ESTADO_NUTRI_ADULTO'].isin(condicoes_obesidade).sum() / len(x)) * 100)
    .reset_index(name='Percentual_Obesidade_Adultos')
)

serie_obesidade_adultos

from pmdarima import auto_arima
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Transformar a coluna ANO em índice da série
serie_obesidade_adultos.set_index('ANO', inplace=True)
serie = serie_obesidade_adultos['Percentual_Obesidade_Adultos']

# Ajustar ARIMA automaticamente
modelo = auto_arima(
    serie,
    seasonal=False,  # Sem sazonalidade
    trace=True,      # Mostra os testes feitos
    error_action='ignore',
    suppress_warnings=True,
    stepwise=True
)

print(modelo.summary())

# Previsão para os próximos 5 anos
n_periods = 5
previsao, intervalo_conf = modelo.predict(n_periods=n_periods, return_conf_int=True)

# Criar DataFrame das previsões
anos_futuros = np.arange(2024, 2029)
df_previsoes = pd.DataFrame({
    'ANO': anos_futuros,
    'Previsao_Obesidade': previsao,
    'IC_Inferior': intervalo_conf[:, 0],
    'IC_Superior': intervalo_conf[:, 1]
})

df_previsoes

import plotly.graph_objects as go

# Base para o gráfico
fig = go.Figure()

# Histórico
fig.add_trace(go.Scatter(
    x=serie.index,
    y=serie.values,
    mode='lines+markers+text',
    name='Histórico (2018–2023)',
    text=[f"{v:.1f}%" for v in serie.values],
    textposition="top center",
    line=dict(color='blue'),
    marker=dict(size=8)
))

# Previsão
fig.add_trace(go.Scatter(
    x=df_previsoes['ANO'],
    y=df_previsoes['Previsao_Obesidade'],
    mode='lines+markers+text',
    name='Previsão (2024–2028)',
    text=[f"{v:.1f}%" for v in df_previsoes['Previsao_Obesidade']],
    textposition="top center",
    line=dict(dash='dash', color='orange'),
    marker=dict(size=8)
))

# Banda de confiança
fig.add_trace(go.Scatter(
    x=pd.concat([df_previsoes['ANO'], df_previsoes['ANO'][::-1]]),
    y=pd.concat([df_previsoes['IC_Superior'], df_previsoes['IC_Inferior'][::-1]]),
    fill='toself',
    fillcolor='rgba(255,165,0,0.2)',
    line=dict(color='rgba(255,255,255,0)'),
    hoverinfo="skip",
    showlegend=True,
    name='Intervalo de Confiança (95%)'
))

# Linha divisória entre histórico e previsão
fig.add_vline(x=2023.5, line=dict(color="gray", dash="dot"))

# Layout
fig.update_layout(
    title='Projeção do Percentual de Obesidade em Adultos (2018–2028)',
    xaxis_title='Ano',
    yaxis_title='Percentual de Obesidade (%)',
    xaxis=dict(dtick=1),  # mostrar todos os anos
    yaxis=dict(range=[serie.min()-1, df_previsoes['IC_Superior'].max()+1]),
    legend=dict(x=0.01, y=0.99),
    template='simple_white'
)

fig.show()

# Filtrar apenas idosos
df_idosos = df_consolidado[df_consolidado['DS_FASE_VIDA'] == 'IDOSO']

# Filtrar apenas quem tem estado nutricional disponível
df_idosos = df_idosos[df_idosos['CO_ESTADO_NUTRI_IDOSO'].notna()]

# Definir o que é considerado "baixo peso" para idosos
condicao_baixo_peso = ['Baixo peso']

# Série: percentual de baixo peso por ano
serie_baixo_peso_idosos = (
    df_idosos
    .groupby('ANO', group_keys=False)
    .apply(lambda x: (x['CO_ESTADO_NUTRI_IDOSO'].isin(condicao_baixo_peso).sum() / len(x)) * 100)
    .reset_index(name='Percentual_Baixo_Peso_Idosos')
)

serie_baixo_peso_idosos

"""# Modelo base + Validação
- Como mencionado pelo professor, houve a falta de uma validação na execução do modelo com anos já existentes, o algoritmo será re-executado utilizando os dados de 2018 a 2022 e os percentuais de `Obesidade em Adultos` serão validados com os dados existentes de 2023 para verificarmos a qualidade das previsões feitas pelo modelo.
"""

serie_treino = serie.loc[2018:2022]  # Histórico usado para treinar
y_real_2023 = serie.loc[2023]        # Valor real de 2023 para validação

from pmdarima import auto_arima

modelo_validacao = auto_arima(
    serie_treino,
    seasonal=False,
    trace=True,
    error_action='ignore',
    suppress_warnings=True,
    stepwise=True
)

previsao_2023_array, intervalo_2023 = modelo_validacao.predict(n_periods=1, return_conf_int=True)

# Acessar corretamente o valor previsto e intervalo
previsao_2023 = previsao_2023_array.item()  # Extrai o valor float
ic_inferior = intervalo_2023[0, 0]
ic_superior = intervalo_2023[0, 1]

print(f"Previsão para 2023: {previsao_2023:.2f}%")
print(f"Intervalo de confiança: {ic_inferior:.2f}% a {ic_superior:.2f}%")
print(f"Valor real em 2023: {y_real_2023:.2f}%")

mae = abs(y_real_2023 - previsao_2023)
mape = (mae / y_real_2023) * 100

print(f"MAE: {mae:.2f}%")
print(f"MAPE: {mape:.2f}%")

"""### Comparativo da Previsão para o ano de 2023 com os Valores Reais"""

import matplotlib.pyplot as plt

plt.figure(figsize=(6, 4))
plt.bar(['Real 2023', 'Previsto 2023'], [y_real_2023, previsao_2023], color=['blue', 'orange'])
plt.title('Validação do Modelo ARIMA com Previsão para 2023')
plt.ylabel('Percentual de Obesidade (%)')
plt.grid(True, axis='y')
plt.tight_layout()
plt.show()

print(f'Diferença dos valores: (Real 2023: {y_real_2023:.2f}) - (Previsão 2023: {previsao_2023:.2f}) = {(y_real_2023 - previsao_2023):.2f}')

"""## Extra: Modelagem de uma Rede Neural para classificação
- Para finalizar como extra modelamos uma rede neural para classificação;
- A função cria toda a arquitetura, ajuste e evaluation. Em sua chamada selecionamos quais variáveis features, target e quantidade de epochs desejados;
- Será útil para entendermos quais variáveis se ajustam melhor à rede.

### Função de Classificação (Functional API, camadas densas decrescentes)
- Arquitetura densa com camadas decrescentes (512 → 64);
- EarlyStopping, ReduceLROnPlateau e ModelCheckpoint;
- Métricas de acurácia e plot de matriz de confusão.
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.layers import Input, Dense, Dropout
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint

def classification_model(df, features, target, epochs):
    # Pré-processamento
    X = pd.get_dummies(df[features], drop_first=True)
    le = LabelEncoder()
    y = le.fit_transform(df[target])
    y = to_categorical(y)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    scaler = StandardScaler()
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)

    # Arquitetura da rede neural
    inputs = Input(shape=(X_train.shape[1],), name="Input")
    x = Dense(512, activation='relu', name="Dense_512")(inputs)
    x = Dropout(0.5, name="Dropout_512")(x)
    x = Dense(256, activation='relu', name="Dense_256")(x)
    x = Dropout(0.4, name="Dropout_256")(x)
    x = Dense(128, activation='relu', name="Dense_128")(x)
    x = Dropout(0.3, name="Dropout_128")(x)
    x = Dense(64, activation='relu', name="Dense_64")(x)
    x = Dropout(0.2, name="Dropout_64")(x)
    outputs = Dense(y.shape[1], activation='softmax', name="Output")(x)

    model = Model(inputs=inputs, outputs=outputs, name="NN_Classifier")
    model.compile(optimizer=Adam(learning_rate=0.001), loss='categorical_crossentropy', metrics=['accuracy'])

    model.summary()

    # Callbacks
    callbacks = [
        EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True),
        ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=3),
        ModelCheckpoint('best_model_classification.keras', save_best_only=True)
    ]

    # Treinamento
    model.fit(X_train, y_train, epochs=epochs, batch_size=32, validation_split=0.2, callbacks=callbacks)

    # Avaliação integrada
    y_pred = model.predict(X_test)
    y_pred_labels = np.argmax(y_pred, axis=1)
    y_true = np.argmax(y_test, axis=1)

    print("\n--- Classification Report ---")
    print(classification_report(y_true, y_pred_labels, target_names=le.classes_))

    cm = confusion_matrix(y_true, y_pred_labels)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=le.classes_)
    fig, ax = plt.subplots(figsize=(8, 6))
    disp.plot(ax=ax, cmap='Blues')
    plt.title("Matriz de Confusão")
    plt.show()

    return model

"""### Treinando os Modelos - Classificação

Primeiro objetivo:

- Classificar o Estado Nutricional: Com base em tudo que mapeamos da sua base df_consolidado (2018–2023), a variável alvo (target) ideal para começar é: `CO_ESTADO_NUTRI_ADULTO`;
- Motivo técnico: É categórica (multiclasse), eutrófico, sobrepeso, obesidade graus, baixo peso;
- Representa risco à saúde pública: Tem importância social e epidemiológica;
- Tem volume razoável de dados limpos (~97.000 registros).

Features recomendadas: Serão escolhidas features que influenciam biologicamente ou socialmente o estado nutricional e que já existem limpas no seu dataset.

| Feature         | Justificativa técnica                                                              |
|-----------------|------------------------------------------------------------------------------------|
| NU_IDADE_ANO    | Idade impacta peso, metabolismo, IMC                                               |
| SG_SEXO         | Homens e mulheres têm padrões nutricionais diferentes                             |
| SG_UF           | Há diferenças regionais de alimentação e saúde                                    |
| DS_RACA_COR     | Pode refletir desigualdades sociais/nutricionais                                   |
| DS_ESCOLARIDADE | Escolaridade influencia acesso a informação sobre saúde                           |
| NU_PESO         | Peso absoluto ajuda diretamente a prever obesidade/desnutrição                    |
| NU_ALTURA       | Altura entra no cálculo de IMC                                                     |
| ANO             | Captura tendência temporal (ex: pandemia, crises econômicas)                      |

"""

# Lista de variáveis usadas no modelo
variaveis_modelo = [
    'CO_ESTADO_NUTRI_ADULTO',
    'NU_IDADE_ANO',
    'SG_SEXO',
    'SG_UF',
    'DS_RACA_COR',
    'DS_ESCOLARIDADE',
    'NU_PESO',
    'NU_ALTURA',
    'ANO'
]

# Verificar nulos apenas nessas colunas
df_consolidado[variaveis_modelo].isna().sum()/len(df_consolidado)

df_consolidado['CO_ESTADO_NUTRI_ADULTO'].unique()

df_consolidado.isna().sum()/len(df_consolidado)

df_consolidado = df_consolidado.dropna(subset=['CO_ESTADO_NUTRI_ADULTO', 'NU_IDADE_ANO', 'SG_SEXO', 'SG_UF', 'DS_RACA_COR', 'DS_ESCOLARIDADE', 'NU_PESO', 'NU_ALTURA', 'ANO'])

classification_model(df=df_consolidado,
                     epochs=50,
                     features=['NU_IDADE_ANO', 'SG_SEXO', 'SG_UF', 'DS_RACA_COR', 'DS_ESCOLARIDADE', 'NU_PESO', 'NU_ALTURA', 'ANO'],
                     target='CO_ESTADO_NUTRI_ADULTO')

"""# **Cronograma**

O projeto será executado ao longo de um cronograma pré-definido. A tabela a
seguir apresenta as principais fases e suas datas estimadas de conclusão:

# **1.Definição do Projeto e Equipe (19/02/2025)**
• Entrega do documento inicial do projeto (PDF), contendo:

• (10/02/2025) Definição da equipe;

• (12/02/2025) Proposta do projeto;

• (12/02/2025) Título do Projeto;

• (12/02/2025) Introdução;

• (12/02/2025) Motivações e Justificativa.

• (12/02/2025) Objetivo

• (12/02/2025) Referências




# **2. Referencial Teórico e Cronograma (28/03/2025) Entregáveis:**

• (21/03/2025) Pipeline da Solução

• (22/03/2025) Referencial Teórico

• (22/03/2025) Cronograma


# **3. Implementação Parcial (25/04/2025) Entregáveis:**

• (23/04/2025) Modelo Base

• (23/04/2025) Análise Exploratória e Pré-processamento dos Dados

• (25/04/2025) Notebook do Projeto

• (25/04/2025) Cronograma Atualizado

• (25/04/2025) Atualização do Pipeline Proposto


# **4. Implementação e Entrega Final (30/05/2025) Entregáveis:**

• GitHub do Projeto

• Vídeo de Apresentação do Projeto

• Notebook do Projeto

• Artigo do Projeto

• Publicação do vídeo de apresentação final no YouTube

# **Referências**

 Referências


• APRELINI, C. M. O. et al. Tendência da prevalência do sobrepeso e obesidade no
Espírito Santo: estudo ecológico, 2009-2018. Epidemiologia e Serviços de Saúde, v.30,
n.3, e2020961, 2021;


• BARBOSA, B. B. et al. Food and Nutrition Surveillance System (SISVAN) coverage,
nutritional status of older adults and its relationship with social inequalities in Brazil,
2008-2019: an ecological time-series study. Epidemiologia e Serviços de Saúde, v.32,
n.1, e2022595, 2023;


• BRASIL. Ministério da Saúde. Marco de referência da vigilância alimentar e nutrici-
onal na atenção básica. Brasília: Ministério da Saúde, 2015. 54 p.;
• BRASIL. Ministério da Saúde. Protocolos do Sistema de Vigilância Alimentar e
Nutricional – SISVAN na assistência à saúde. Brasília: Ministério da Saúde, 2008;


9
• BRASIL. Ministério da Saúde. SISVAN – Sistema de Vigilância Alimentar e Nutrici-
onal (Portal eletrônico). Disponível em: https://sisaps.saude.gov.br/sisvan/. Acesso
em: 22 mar. 2025;


• BRASIL. Ministério da Saúde. Vigilância Alimentar e Nutricional (Portal APS). Dis-
ponível em: https://www.gov.br/saude/pt-br/composicao/saps/vigilancia-alimentar-
e-nutricional. Acesso em: 22 mar. 2025;


• CONSELHO NACIONAL DE DESENVOLVIMENTO CIENTÍFICO E TECNOLÓ-
GICO (CNPq). Aberta chamada de apoio a projetos em ciência de dados. Brasília:
CNPq/Ministério da Saúde, 20 ago. 2020. Disponível em: https://www.gov.br/cnpq/pt-
br/assuntos/noticias/destaque-em-cti/aberta-chamada-de-apoio-a-projetos-em-ciencia-
de-dados. Acesso em: 20 mar. 2025;

• FUNDAÇÃO OSWALDO CRUZ (Fiocruz). Obesidade em crianças e jovens cresce no
Brasil na pandemia. Observa Infância/Fiocruz, 2023. Disponível em: https://portal.fiocruz.br/noticia/obe
em-criancas-e-jovens-cresce-no-brasil-na-pandemia. Acesso em: 20 mar. 2025;


• MREJEN, M.; CRUZ, M. V.; ROSA, L. O Sistema de Vigilância Alimentar e
Nutricional (SISVAN) como ferramenta de monitoramento do estado nutricional de
crianças e adolescentes no Brasil. Cadernos de Saúde Pública, v.39, n.1, e00169622,
2023;


• MOURÃO, E. et al. Tendência temporal da cobertura do Sistema de Vigilância
Alimentar e Nutricional entre crianças menores de 5 anos da região Norte do Brasil,
2008-2017. Epidemiologia e Serviços de Saúde, v.29, n.2, e2019377, 2020;


• SILVA, O. L. O. et al. Vigilância alimentar e nutricional de crianças indígenas menores
de cinco anos em Mato Grosso do Sul, 2002-2011. Epidemiologia e Serviços de Saúde,
v.23, n.3, p.541-546, 2014;


• SILVA, R. P. C. et al. Sistema de Vigilância Alimentar e Nutricional: tendência tempo-
ral da cobertura e estado nutricional de adultos registrados, 2008-2019. Epidemiologia
e Serviços de Saúde, v.31, n.1, e2021605, 2022.
"""

#@title **Avaliação**

EDA_e_preprocessamento = 10 #@param {type:"slider", min:0, max:10, step:1}

Modelo_base = 10 #@param {type:"slider", min:0, max:10, step:1}

Revisao = 10 #@param {type:"slider", min:0, max:10, step:1}

Apresentacao_geral = 10 #@param {type:"slider", min:0, max:10, step:1}

#@title **Nota Final**
nota = 0.4*EDA_e_preprocessamento + 0.2*Modelo_base + 0.2*Revisao + 0.2*Apresentacao_geral

Nota final do trabalho 10.0

nome	nota
0	Aluno 1	10.0
1	Aluno 2	10.0
2	Aluno 3	10.0
3	Aluno 4	10.0
4	Aluno 5	10.0